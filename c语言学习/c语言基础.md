##### 程序语言的发展
	机器语言    汇编语言    高级语言
	1）机器语言 
		0和1组成
	2）汇编语言
		符号化的机器语言，用一个符号(单词、数据等)代表一条机器指令
		由于计算机只能识别二进制命令，所以需要翻译代码，这是“编译器”的重任啊。
		汇编语言是面向机器的，依赖于硬件，代码可移植性差。
	3）高级语言
		远离对硬件的直接操作，不需要对硬件很熟悉。
		简单，易用，易于理解，结构和文法类似于普通英文。
		可移植性好

	C语言是一门面向过程的语言，非面向对象的语言
	C语言可以直接操作硬件，还可以直接访问内存地址，适用于编写系统软件，图形处理，单片机程序，嵌入式系统开发甚至用于科研。
	C语言标准：ANSI C. (American National Standards Institute)

##### C程序执行
	先上张图片
	![C程序执行流程](c_scheme.png)
	程序编译：编译器除了将.c源文件转为目标文件之外，还有一个非常重要的功能：语法检查
	程序链接：源文件编译成功后，会生成一个.o目标文件，这是一个二进制文件，但是还不能运行。
		原因：
		1）多个文件写的一个功能，编译后会生成多个.o目标文件，单独的.o文件都不能运行，需要将所有的相关的.o文件组合在一起
		2）除了组合所有的目标文件后，还需要将C语言的函数库包含进来，才能生成可执行文件
		在window中会生成一个.exe文件，在类unix系统中，生成一个.out文件
	
		使用gcc编译器时，可以指定生成的可执行文件名
			gcc -o executable_file source.c
	运行程序
		./a.out   a.out为可执行文件

##### 数据
	静态数据
		常见的是存储在磁盘上的文件，比如图片、文件和视频等
	动态数据
		当运行某个程序(软件)时，整个程序就会加载到内存中，在程序运行的过程中，会产生各种各样的临时数据，这些临时数据都是存储在你内存中的。
		当程序停止运行或者计算机被强制关闭时，这个程序产生的所有临时数据都会被清除。
	动态数据和静态数据的转换
		硬盘和内存时计算机使用最频繁的两个硬件，他们之间的数据经常需要进行转换
		比如一个苍老师.mp4和暴风影音，要使用暴风影音来播放。
		首先需要打开暴风影音软件，然后将暴风影音加载到内存中，紧接着计算机会读取硬盘中视频文件的内容到内存中，暴风影音进行解析，以视频的形式呈现给用户看。

		如果下载视频到本地，同样要加载暴风影音到内存中，然后从互联网上下载的数据加载到内存中，然后再放到磁盘上，完成了从动态数据到静态数据的转换。

	存储形式
		计算机只能识别0和1，文件视频等都是以这样方式存储的，这种方式称为二进制存储。

		一个字节有8个比特位，可以表示2^8个数据 1byte = 8 bit
		1Kb = 1024b; 1Mb = 1024Kb; 1Gb = 1024Mb; 1Tb = 1024Gb

	类型
		![变量类型](https://github.com/mrfengz/getskills2/tree/master/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/c_var_type.png)
		指针
		构造类型			数组 | 结构体(struct) | 共用体(union) | 枚举(enum)
		基本数据类型 		int float double char
		空类型			void
	变量
		定义： 在内存中分配一块存储空间给变量，方便以后存储数据	=> 类型 变量名
		初始化： 给变量赋值    => 变量名 = 值
		变量类型： 除了决定存储空间的大小之外，还用来约束存放的数据类型
		注意：变量不能重复定义。 int i =10; int i;//报错
	常量
		const int i = 10;

##### 进制
	十进制：	逢十进一 0-9 	
	二进制：	逢二进一 0-1	@以 0b 或者 0B开头； n位二进制数表示的最大值：2n-1
	八进制：	逢八进一 0-7	@以 0 开头 一位八进制可以由三位二进制数表示 0b11110011 = 0b+011+110+011 = 0363
	十六进制： 逢十六进一 0-9A-F @以 0x 开头，一位十六进制表示的范围是0-15共16中情况，是一位二进制的4倍，所以一位16进制可以用4位二进制表示

	printf() 支持的格式
		格式符		功能
		%d			带符号的十进制形式输出整数
		%o 			不带符号的八进制形式输出整数
		%x			不带符号的十六进制形式输出整数
		%u			不带符号的十进制形式输出整数
		%c 			输出一个字符
		%s			输出一个或多个字符
		%f			以小数形式输出单、双进度数，默认输出6位小数
		%e			以标准指数形式输出单、双进度数，数字部分小数位数是6位

##### 变量与内存
	字节和地址
		计算机中的内存是以【字节】为单位的存储空间。内存中的每一个字节都有一个唯一的编号，这个编号就称为地址。类似于酒店房间的房间号。
	
	变量存储
		变量不同类型占用的存储空间大小不一样，并且不同位[16/32/64位]的编译器分配的大小也是不一样的
		int b = 10; 和 char a= 'A' 的存储形式
		![变量类型](https://github.com/mrfengz/getskills2/tree/master/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/var_storage.png)
		1）变量也有地址，存储单元的第一个字节的地址就是该变量的地址。变量a的地址是ffc5,变量b的地址是ffc1
		2）内存寻址是从大到小的，分配变量也是从内存地址较大的字节开始的。变量a先定义，所以地址更大一些
		3）变量b存储的内容时 ffc4 -> ffc3 -> ffc2 -> ffc1 拼接起来就是变量b的值了

		查看变量的内存地址
			printf("变量a的地址是%p\n", &a);  %p是专门用来输出地址的，&是取地址符的意思

	负数的二进制形式
		任何数值在内存中都是以补码的形式存储的。
		1）正数的补码与原码相同。比如9的补码和原码都是1001
		2）负数的补码等于它正数的原码取反后再+1
			以-10为例
			（1）10的二进制		00000000 00000000 00000000 00001010
			（2）对10的二进制取反	11111111 11111111 11111111 11110101
			（3）对取反的结果+1	11111111 11111111 11111111 11111110
	变量作用域
		变量作用的范围。如果是函数中定义的变量，函数调用时函数变量分配内存，赋值，运行结束后，释放该部分变量
		代码块{}中的变量也会在运行完变量块时释放
			int main(){
				int b; //变量b会在函数调用完毕后被销毁
				{
					int a = 10;
					printf("a=%d\n",a);
				}
				a = 9; //此处编译错误，因为代码块运行完后，变量a被销毁了
				return 0;
			}
		不同作用域中变量的名字可以相同，系统会给它们分配不同的空间
		变量没有赋值，不要使用，里面的数据是垃圾数据，绝对让你大跌眼镜

##### 基本数据类型
	变量的取值范围
		int 	4字节 	首位是符号位 表示范围是 -2^31 - 2^31-1
		char 	1字节 	-2^7 ~ 2^7
		float	4字节	3.4e^-38 ~ 3.4e^38, -3.4e^38 ~ -3.4e^-38
		double	8字节	1.7e^-308 ~ 1.7e^308, -1.7e^308 ~ -1.7e^-308

		数值越界 得到的结果不堪设想
		字符型变量不能存储汉字(一个汉字要两个字符...)

	ASCII(American Standard Code for Information Interchange).
		1)基于拉丁字母的一套编码系统。是一个字符集--字符的集合。包括了所有大小写字符，标点符号和一些特殊的控制字符，一共128个字符。
		2)ASCII在内存中是以二进制形式存储的，而且只占用1个字节。二进制的值，就是这个字符的ASCII的值。
		char c1 = 65;  //注意用char存储表示A的二进制数，也就是ASCII的值
		char c2 = 'A'; 
		printf("%c %c", c1,c2); // A A
		3)注意字符串的6和表示ASCII的值6是不同的
		char c2 = '6';
		char c1 = 6;
		printf("c1=%d c2=%d",c1,c2);//c1=6 c2=54

	说明符
		int类型的 short/long unsigned/signed
			1. 上面的几种类型，作为说明符时，可以省略 int.
			如 short int s1 = 1; 可以简写为 short s1 = 1;
			2. 能同时使用两种不同的说明符，但是不可以连续使用相同的说明符
			如 unsigned long s2 = 2; 但不能写成 short long s2 = 23;
			3. 可以连续使用两个 long （32bit编译器，long long的范围是8个字节，long是4个字节； 64位，long和long long都是8个字节，）
			如 long long s3 = 34;
			4. long的用法
				为了区分int和long，一般在long类型后面加上l
				int a = 100;	// 4字节
				long a = 100l;	// 8字节
				long long a = 100ll; //两个l,8字节
				
				输出long类型的数据时，应该用%ld,
				long long类型的，应该使用 %lld, 
				%d是用来输出int类型的，如果长度不够，会变成垃圾数据

			64位编译器环境中
				short 	16bit
				int		32bit
				long	64bit
	自动类型提升
		系统会自动对占用内存较少的类型做一个“自动类型提升”的操作，从而实现不同类型的计算。
		自动类型提升只是在变量计算的过程中进行的，并不会改变变量的类型。
		int a = 10;
		double b = 9.34;
		double c = a + b;
		printf("%f \n", c);

	强制类型转换
		int a = 10.7; // a = 10, java中会报错，不严格
		int a = (int)10.7; // 10

##### 运算符
		运算原则：相同类型的值才能进行运算，而且运算结果依然是同一数据类型
	算术运算符
		double a = 10.0/4; // a = 2.500000
		double a = 10 / 4; // a = 2.000000
		如果想让两个整数相除不损失精度，可以使用 类型转换
		double a = (double) 10 / 4;

		% 运算符两侧的数都必须是整数。
		负数取余，余数与被除数的符号决定
	赋值运算符
	自增/减运算符
		int a = 10;
		a = a++; // a = 10  
	sizeof
		计算一个变量、常量、一种数据类型所占的内存字节数
		sizeof(常量/变量)
		sizeof 常量/变量
		sizeof(数据类型)
	逗号运算符
	关系运算符
	逻辑运算符
	三目运算符
		表达式A ? 表达式B : 表达式C
	位运算符

##### 流程控制
	顺序结构
	if 选择结构
	switch 选择结构
	循环结构 while
	循环结构 do-while
	循环结构 for
	break 和 continue

##### 函数
	声明、定义
	形参、实参
	返回值

	函数被调用时，必须先声明。如果调用地址前面已经定义好了，可以直接调用。否则，要先声明
		int sum(int a, int b);
	编译时检测函数是否声明。链接时检测函数是否定义。

##### 函数的声明定义
	多源文件开发
		如果有一个main.c和一个sum.c源文件。需要编译为同一个目标文件。
		main.c中调用sum()方法时，需要先声明函数，然后一起编译，可以调用该函数。
		gcc main.c sum.c //具体见sum.c和main.c文件
	#include
		这是C语言的预处理指令之一。预处理是指在编译之前做的处理。
		被包含的文件扩展名为.h，这样的文件我们成为头文件。
		#include包含的文件不仅限于.h头文件，可以包含任何编译器能识别的c/c++代码文件，如.c,.cpp,.hpp，甚至是.abc，.txt文件都可以
		包含进来的文件，替换源文件中的#include指令，从而可以使用源文件中的函数等

		#include <> 和  #include ""的区别
		1）前者会在编译器设置的include路径中搜索，然后再系统的INCLUDE环境变量内搜索
		2）后者会先在包含该#include "abc.c"的文件所在目录中查找，然后才会去上面的两个地方去查找
		且后者可以使用绝对或者相对路径

		一般函数声明定义在.h文件中，函数定义放在.c源文件中 
		使用时在main.c中，引入 func.h,然后编译时同时编译main.c和func.c函数
		直接引入func.c，编译时不会报错，但是链接时会报错
		/*
		ld: 1 duplicate symbol for architecture x86_64
		clang: error: linker command failed with exit code 1 (use -v to see invocation)
		 */

##### printf() 和 scanf() 函数	
		printf()
		输出宽度 
			%4d d显示宽度为4个，如果不够，在左边补空
			%-4d d显示宽度为4个，如果不够，在右边补空
			%.2f 显示时保留两位小数点
			%8.1f 总过长度为8位，小数点为1位

			%x 16进制
			%o 8进制

		scanf("%d", &a); //获取标准输入设备输入的数据，第二个变量为 &地址
		scanf("%d-%d-%d", &a, &b, &c);  // 10-20-30 变量空格应该与样式一致，为空时可以为tab 空格和回车分割

##### 批量操作数据
	内存中的每一个字节都有一个唯一的编号，这个编号就是地址
	获取数据的地址
		int c = 123;
		printf("%x", &c); 
	数组
		一维数组
			定义
				int a[5];
			存储
				分配一段连续的存储空间来存储数组元素
				数组名代表着数组的起始地址 a == &a[0]
			初始化
				int a[5] = {1,2,3,5,7}
				要注意数组的下标，C语言不会检测下标越界行为
				a[2] = 12;
				a = {1,23,34,6,88} //错误 a表示的是数组的地址，是个常量
			作为参数
				如果整个数组作为形参传递，那么形参与实参存放在同一个存储空间，修改形参，实参也会改变、
				void test(int a[]){
					b[0] = 9;
				}
				int main()
				{
					int a[3];
					a[0] = 10;
					test(a);
					a[0]; //9
				}

			二维数组
				定义并初始化
					int a[2][3] = {{2,3,5},{33,45,69}}
					int a[2][3] = {2,3,5, 33, 45, 69};
					int a[2][3] = {{2,3},{69}}; //部分元素初始化
					初始化可以省略行数，但是不能省略列数
					int a[][3] = {1,2,3,4,5,6}

##### 字符串
	字符串可以看做特殊的数组，为了跟普通字符数组区分开来，要在字符串尾部加上'\0'结束标识。
	char a[3] = {'f','d','\0'}; //'fd'
	char b[] = 'fd'; //系统会自动在字符串尾部加上一个\0结束符

	输出字符串
		printf()
		puts(a);  //输出后会自动换行，一次只能输出一个变量

	输入字符串
		scanf()
			char a[10];
			scanf("%s", a); //不要写成&a, 因为a表示的就是数组的地址
		gets()
			gets(a); //一次只能读入一个字符串，scanf可以读取多个
			gets()可以读入包括空格、tab,知道回车为止

	字符处理函数
		1)输出字符	
		putchar() 一次只能输出一个字符
			putchar(65);	//A
			putchar('A'); 	//A
		2)读入字符 
		getchar() 获取用户输入的字符给变量c
			char c;
			c = getchar(); //可以读入回车符，连续敲击两次
		3)检测字符串字符个数，不包括\0
			strlen(c)
			int size = strlen("mj"); // 2
		4)将数组b中内容拷贝到a中
			strcpy(a,b)
			char s[10];
			strcpy(s, "nick"); // s = 'nick'
		5)字符串拼接
			strcat(s1, s2); //将s2拼接到s1后
			char s1[30] = 'love';
			strcat(s1, " me"); // love me
		6)逐个比较两个字符串的大小【按照ASCII码值大小】
			strcmp(字符串1，字符串2)
			相等为0，不相等返回第一个不相等字符的ASCII码值的差

##### 指针
	直接引用
		char a;
		a = 10;
		程序内部操作：系统自动将变量名转换为变量的存储地址，根据地址找到变量a的存储空间，然后将该值的二进制表示形式存到变量a的存储空间中。
		通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，成为变量的直接引用
	间接引用
		首先将变量a的地址存放在另一个变量中，比如b中，然后通过变量b间接引用变量a，间接读写变量a的值
		先根据变量b获取变量b的地址，然后去除变量b中存储的内存(a的地址)，再根据a的地址找到a的存储空间，然后修改a的值
	指针定义
		类型标识符 *指针变量名
		int *p; // * 是说明符，说明这个变量是个指针变量，且不能省略，不属于变量名的一部分
		float *q;
	指针初始化
		int a = 10;
		int *p;
		p = &a; 
		//或者
		int *q = &a;

		//改变a的值 此处的 * 是一个指针运算符
		*p = 9; // a = 9
		// 获取指针指向变量的值
		char value = *p;
		printf("去除的a的值：%d", value); // 9
	使用注意
		指针变量没有指向确定的地址前，不要对它所指向的内容赋值
	指针的用途
		1) 函数中改变实参的值 point_sum.c
		2) “多返回值”	mutli_return.c
	关于指针的一些疑问
		1）一个指针变量占用多少字节的内存空间？是否会随指向变量类型而改变？
			编译器(位)		16	32	64	
			占用内存(字节)		2	4	8

		2）指针为什么要对指向的变量分类型？
		如果指针类型与指向的变量类型不一致，会导致读取变量时，读取的内存长度不同，可能会出错。
		如char类型的变量，只有1字节，但是用int *p = &c; 就会从&c的地址起，读两个字节，导致结果不正确

##### 指向一维数组元素的指针
	用指针指向一维数组的元素
		int a[2];
		int *p;
		p = &a[0]; //指向数组的第0个元素 由于数组名代表着数组的首地址，所以 可以写为 p = a;
		*p = 10; //修改指针指向元素的值
		printf("a[0]=%d\n", a[0]); // a[0]=10
	用指针遍历数组元素
		int a[4] = {1,3,4,6};
		int *p = a;
		int i;
		for(i = 0; i < 4; i++) {
			int value = *(p+i); // 获取指针下一个元素的值 地址增加可能为1， 2， 4， 8，跟类型有关
			// 也可以写为 int value = *(a+i); value = *(p++);
			printf("a[%d] = %d\n", i, value);
		}
	引用数组元素的方法
		下标法： a[i]
		指针法：*(p+i) 或者 *(a+i)
	数组、指针与函数参数
		1）把数组名作为函数实参时，是把实参数组的首地址传递给形参数组，两个数组共同占用同一段内存空间，修改形参，实参值也会变化
		2）形参和实参可以分别使用数组名和指针，这样就有4中组合方式了，效果一样

##### 指针与字符串
	指针遍历字符串
		char *p = c; // *p = &c[0];
		示例代码见point_loop_string.c
	指针直接指向字符串
		示例代码见 point_strlen.c函数
		string.h 声明
		size_t 	strlen(const char *); 			// strlen()
		char	*strcpy(char *, const char *); 	//字符串拷贝函数
		char	*strcat(char *, const char *);	//字符串拼接函数
		int 	strcmp(const char *, const char *); //字符串比较函数
		这几个函数的参数都是指向字符变量的指针类型，因此可以传入指针变量或者数组名

		printf("%s",s); 也可以正常使用
	注意
		指针指向字符串的其他方式
			char *s;
			s = "msj";

			char s[10];
			s = "msj"; //s是一个常量，表示数组的首地址，所以此处会报错

			char *s = "msj";
			*s = "like"; //由于s指向数组的第一个元素，只能存储一个字符，这里给出了长度为4的字符串，造成内存溢出
			*s = "A"; //也是错误的，因为s指向一个常量字符串，不允许修改常量内部的字符

	修改字符串的首字母
		1) char a[] = "love"; //定义一个字符串变量
			a[0] = "L";
		2) char *p2 = "love"; //定义了一个字符串常量
			*p2 = "L"; //错误，常量不允许修改内部字符

##### 预处理指令
	简介
		1）对源程序编译之前，会先对一些特殊的预处理指令作解释
		2）为了区分一般语句和预处理指令，所有预处理指令以#开头，且结尾不用;
		3）预处理指令可以出现在程序的任何位置，作用范围是从出现的位置到文件结尾
		4）C语言提供的预处理指令主要有：宏定义，文件包含和条件编译

	（一）宏定义
		分类
			带参数和不带参数的宏定义
		1）不带参数的宏定义
			#define 宏名 字符串
			#define PI 3.14
			作用是在编译预处理时，将源程序中所有宏名替换成右边的字符串，常用来定义常量
			
			注意：
				1 一般用大写字母，以便于普通变量区分
				2 双引号括起来的字符串内的字符，不进行宏替换
				3 编译预处理用字符串替换宏名时，不检查语法，只是替换。编译时才对已经展开宏名的源程序进行语法检查
				4 宏名有效范围是从定义的位置到文件结束。如果需要中止宏定义的作用域，可以使用#undef #undef PI
				5 定义一个宏时，可以引用已经定义的宏名
					#define L = 2*PI*R;
		2）带参数的宏定义
			一般形式
				#define 宏名(参数列表) 字符串
			作用
				在编译预处理时，将源程序中所有宏名替换成右边的字符串，并且将 字符串中的参数 用 宏名右边的参数列表 中的参数替换
				#include <stdio.h>
				#define average(a, b) (a+b)/2
				int main()
				{
					int a = average(10, 5);
					printf("平均值%d",a);
					return 0;
				}
			注意
				1 宏名和参数列表之间不能有空格
				2 带参数的宏在展开时，只作最简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数
				#define D(a) 2*a
				int b = D(3+4); // b = 2 * 3+4 => 10

				#define D(a) 2*(a) //括起来后， b = 2*(3+4) => 14
				3 同理，计算后的结果最好也用括号括起来
			与函数的区别
				1）宏定义不涉及存储空间的分配，参数类型匹配、参数传递、返回值问题
				2）函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。带参数的宏比函数具有更高的执行效率

	(二) 条件编译
		希望程序中的一部分代码只有在满足一定的条件时才进行编译，这就是条件编译
		基本用法
			#if 条件1
				... code1 ...
			#elif 条件2 
				... code2 ...
			#else 
				... code3 ...
			#endif
			上面的条件一般是判断宏定义，而不是变量，因为条件编译是在编译之前做的判断，而变量是在运行时才产生的

		还可以根据是否定义过某个宏来进行条件编译
		#if defined(MAX) //!defined(MAX)
			... cond ...
		#endif 

		#ifdef MAX  // 与#if defined(MAX)的用法基本一致
			... code ...
		#endif

	(三) 文件包含
		将一个文件的全部内容拷贝到另一个文件中
		1）#include <文件名> 
		2）#include "文件名" //绝对或者相对路径

		使用注意
			1 #include 指令允许嵌套包含，但不允许递归包含
			2 #include 指令可能导致多次包含同一个头文件，降低编译效率
				为了防止重复包含，可以这样处理
				//第一次包含时，定义一个_ONE_H,再次包含时，因为已经定义过这个宏，就不在声明函数了
				#ifndef _ONE_H_
					#define _ONE_H_
						void one();
				#endif

##### 变量类型与作用域
	1 局部变量
		在函数内部定义的变量，成为局部变量。形参也属于局部变量
	  作用域
		只在定义它的函数内部有效，即只能在定义它的函数内部使用，其他函数不能使用它。
	2 全局变量
		在所有函数外部定义的变量，称为全局变量
	  作用域
		从定义变量的位置到源程序结束的位置。可以被其他函数共享
	3 变量的存储类型
		变量的存储类型是指变量存储在什么地方。
		存储变量的3个地方：普通内存、运行时堆栈、硬件寄存器。
		变量的存储类型决定了变量何时创建、何时销毁以及它的值能保存多久，也就决定了变量的声明周期

		C语言根据变量类型存储类型的不同，可以把变量分为：自动变量、静态变量和寄存器变量
		1）自动变量
			存储在堆栈中的。
			被关键字 auto 修饰的局部变量都是自动变量，但是极少使用该关键字，因为所有的局部变量，默认都是自动变量
			生命周期：只有程序执行到声明自动变量的代码块(函数)时，自动变量才会被创建；代码块执行完毕后，这些变量就会自行销毁。如果函数被重复调用，那么每次都会重新创建这些变量。
		2）静态变量
			定义：存储在静态内存中的，不属于堆栈。
			静态变量：（1）所有的全局变量（2）被关键字static修饰的局部变量
			生命周期：在程序运行【之前】创建，在整个程序运行期间始终存在，直到程序结束。
			void test()
			{
				static int b = 0;
				b++;
			}
			多次调用test(), 但是static int b = 0;只会被创建一次，且第二次及以后不会再初始化，并且b只能在函数内使用。
		3）寄存器变量
			定义：存储在硬件寄存器中的变量。比存储在内存中的变量访问具有更高的访问效率(默认情况下，自动变量和静态变量都是放在内存中的)
			寄存器变量：（1）被关键字register修饰的自动变量（2）只有自动变量才可以，全局与静态变量都不可以（3）变量类型仅限于int/char和指针类型变量使用
			生命周期：因为寄存器变量本身就是自动变量，所以函数中的寄存器变量在调用该函数时，占用寄存器中存放的值，当函数结束时，释放寄存器，变量消失。
			注意：
				1 由于寄存器数量有限，不能使用太多的寄存器变量。如果使用饱和时，程序将其自动转为自动变量处理
				2 为了提高运算速度，一般会将一些频繁使用的自动变量定义为寄存器变量。
				int main()
				{
					register int a;
					return 0;
				}

##### 枚举
	枚举是一种基本数据类型，并不是构造类型，可用于声明一组常量
	定义：
		enum 枚举名 {枚举元素1，枚举元素2,...}
		enum Season {spring, summer, autumn, winter}
		1）先定义类型，在定义枚举变量
			enum Season {spring, summer, autumn, winter};
			enum Season s;
		2）定义枚举类型的同时定义枚举变量
			enum Season  {spring, summer, autumn, winter} s;
		3）省略枚举名称，直接定义枚举变量
			enum {spring, summer, autumn, winter} s;
	注意：
		1）C语言编译器会将枚举元素作为整型常量来处理，成为枚举常量
		2）枚举元素的值取决于枚举各元素排列的先后顺序。默认第一个枚举元素值为0，第二个为1，。。
		3）也可以在定义枚举类型时改变枚举元素的值
			enum Season {sping,summer = 3, autumn, winter}
			spring=>0, autumn=>4,winter=>5
	赋值
		enum Season {spring, summer, autumn, winter}
		s = spring; // s = 0;
		s = 3; //s = winter

	循环
		for(s=spring; s<=winter; s++){
			printf("枚举元素%d\n", s);// 0 1 2 3
		}

##### 结构体
	数组：每个元素必须是相同的类型
	结构体：由不同的类型的数据构成的整体。如学生，可以由姓名、身高、年龄等组成，数据类型也不相同
	定义：
		形式：struct 结构体名{
			类型1 成员名1;
			类型2 成员名2;
			...
		};
		结构体内部的元素，也就是组成成分，我们一般称为成员。
	结构体变量定义：
		1）方式一
			struct Student {
				char *name;
				int age;
			};
			// 定义一个结构体变量，变量名为stu.
			struct Student stu;
		2）方式二
			struct Student {
				char *name;
				int age;
			} stu;
		3）方式三
			struct {
				char *name;
				int age;
			} stu;
	注意：
		1）不允许对自身递归
			struct Student {
				int age;
				struct Student stu;
			}
		2）可以包含别的结构体
			struct Date {
				int year;
				int month;
				int day;
			};
			struct Student {
				char *name;
				struct Date birthday;
			};
		3）定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不给int类型本身分配空间一样。只有定义属于结构体的变量时，系统才会分配存储空间。
			struct Student {
				char *name;
				int age;
			};
			struct Student stu; //此处才会分配空间
		4）结构体变量占用的内存空间是其成员所占用内存之和，而且各成员在内存中按定义的顺序依次排列
	
	结构体的初始化
		struct Student {
			char *name;
			int age;
		};
		struct Student stu = {"MJ", 27};
		//使用 .成为成员运算符
		stu.age = 34;
		stu.birthday.year = 1990; // 结构体内有结构体时，可以使用多级.来访问最底层成员

		struct Student stu2 = stu; //结构体变量之间，可以进行整体赋值

	结构体数组
		定义：
			struct Student {
				char *name;
				int age;
			};
			struct Student stu[5]; //定义1

			struct Student {
				char *name;
				int age;
			} stu[5]; //定义2

			struct {
				char *name;
				int age;
			} stu[5]; //定义3
		初始化
			struct {
				char *name;
				int age;
			} stu[2] = {{"MJ",27}, {"JK", 33}};
			也可以用数组下标访问每一个结构体元素，跟普通数组的用法一样

	结构体作为函数参数
		结构体作为函数参数传递时，其实传递的时全部成员的值，也就是将实参中成员的值——赋值给对应的形式参数。因此，形参的改变不会影响到实参。
		void test(struct Student stu){
			printf("修改前的形参：%d\n", stu.age);
			stu.age = 19;//实参未变化，形参发生了变化
		}

	指向结构体的指针
		每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量。
		结构体指针变量的定义形式： struct 结构体名称 *指针变量名
		访问结构体成员的3中方式
			1）结构体变量名.成员名
			2）(*指针变量名).成员名
			3）指针变量名->成员名

##### typedef类型别名
	作用：使用typedef关键字为各种数据类型定义一个新名字(别名).
	typedef int Integer;
	typedef Integer MyInteger; //起过别名后可以继续起别名

	typedef与指针
		typedef char *String;  //给指针起别名 char * as String
		示例见typedef_point.c

	typedef与结构体
		先定义结构体
		typedef struct MyPoint Point;
		或者
		typedef struct MyPoint {
			float x;
			float y;
		} Point;
		或者
		typedef struct {
			float x;
			float y;
		} Point;
		
	typedef 与指向结构体的指针
		typedef struct {
			float x;
			float y;
		} Point;
		typedef Point *PP; //指向结构体的指针

		//定义结构体变量
		Point point={10,20};
		//定义指针变量
		PP p = &point;
		//利用指针变量访问结构体成员
		printf("x=%f,y=%f", p->x, p->y);
			
	typedef 与枚举类型
		enum Season {spring,summer,autumn,winter};
		typedef enum Season Season; //可简化为 typedef enum Season{spring,summer,autumn,winter}
		
		//定义枚举变量
		Season s = spring;

	typedef 与指向函数的指针
		int sum(int a, int b){...}

		int (*p)(int, int) = sum(); //定义指向函数的指针
		(*p)(4,6); //利用指针调用函数

		//定义别名
		typedef int (*MySum)(int, int);
		
		//定义一个指向sum函数的指针变量p
		MySum p = sum;
		
		//利用指针变量p调用sum函数
		(*p)(4,6);

	typedef 与#define
		typedef char *String1;
		#define String2 char *;

		int mian()
		{
			String1 str1, str2; // char *str1, char *str2;
			String2 str3, str4; // char *str3, str4; 第二个只是普通的char变量
		}











